<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"> 
<head> 
  <title>Themenabend Haskell &amp; Yesod</title> 
  <!-- Slidy: http://www.w3.org/Talks/Tools/Slidy2/ -->
  <link rel="stylesheet" type="text/css" media="screen, projection, print" href="slidy.css" /> 
  <script src="slidy.js" charset="utf-8"
  type="text/javascript"></script> 

  <!-- Highlighting: http://zenzike.com/posts/2010-10-14-highlighting-haskell-with-shjs -->
  <link rel="stylesheet" type="text/css" href="sh_style.css" />
  <script type="text/javascript" src="sh_main.js" > </script>
  <script type="text/javascript" src="sh_haskell.js" > </script>
  <script type="text/javascript" src="sh_init.js" > </script>

  <!-- Custom style -->
  <style type="text/css"> 
    .cover {
      text-align: center;
    }
    .speakers {
      margin: 1em 0;
    }
    .speakers li {
      list-style-type: none;
      margin: 0;
      padding: 0;
    }
  </style> 
</head>
<body onload="sh_highlightDocument();">

<div class="slide cover"> 
  <h1>Themenabend Haskell &amp; Yesod</h1>
  <ul class="speakers">
    <li>maloi &lt;mm@noexample.de&gt;</li>
    <li>Astro &lt;astro@spaceboyz.net&gt;</li>
  </ul>
  <p>Chaos Computer Club Dresden</p>
  <p>2012-08-29</p>
</div> 

<!--
Geplante Agenda, entferne was du in Folien umgesetzt hast.

* Intro: (astro) (10 min)
  * Bücher/Doku
  * Hackage/Cabal
  * Hayoo/Hoogle
-->
<!--
* Syntax, Currying, Typen, Lazyness  (astro)  (min. 30min)
-->
<div class="slide">
  <h2>Syntax</h2>
  <ul>
    <li>
      <p>Rumpf:</p>
      <pre class="sh_haskell">f = undefined</pre>
    </li>
  </ul>
</div>

<!--
* Monads, Functors, Applicatives (maloi) (30 min)
-->
<div class="slide">
  <h2>Functors - Motivation</h2>
  <ul class="incremental">
    <li>
      <p>Eine Funktion, die jeder liebt:</p>
      <pre class="sh_haskell">map :: (a -> b) -> [] a -> [] b -- map :: (a -> b) -> [a] -> [b]</pre>
    </li>
    <li>
      <p>Wie sieht so eine Funktion z.B. fuer Baeume aus?</p>
      <pre class="sh_haskell">data Tree a = Leaf a | Node a (Tree a) (Tree a)</pre>
      <pre class="sh_haskell">mapTree :: (a -> b) -> Tree a -> Tree b</pre>
    </li>
    <li>
      <p>Maybe just nothing</p>
      <pre class="sh_haskell">data Maybe a = Just a | Nothing</pre>
      <pre class="sh_haskell">mapMaybe :: (a -> b) -> Maybe a -> Maybe b</pre>
    </li>
  </ul>
</div>
<div class="slide">
  <h2>Functors - Motivation (2)</h2>
  <ul class="incremental">
    <li>
      <pre class="sh_haskell">map      :: (a -> b) -> []    a -> []    b</pre>
      <pre class="sh_haskell">mapTree  :: (a -> b) -> Tree  a -> Tree  b</pre>
      <pre class="sh_haskell">mapMaybe :: (a -> b) -> Maybe a -> Maybe b</pre>
    </li>
    <li>
      <p>Die Funktionen haben - bis auf Umbenennung des Typ-Konstruktors - die gleiche Signatur<p>
    </li>
    <li>
      <p><strong>Type classes to the rescue!</strong></p>
    </li>
    <li>
      <p>Zuvor aber ein kleiner Ausflug</p>
    </li>
  </ul>
</div>
<div class="slide">
  <h2>Kinds: Typen von Typen - WTF?</h2>
  <ul class="incremental">
    <li>
      <p>In Haskell hat jeder Ausdruck einen Typ<p>
    </li>
    <li>
      <p>Diese Typen haben wiederum "Typen" - <strong>Kinds</strong><p>
    </li>
    <li>
      <p>Jeder monomorphe Typ (nullstelliger Typ-Konstuktor) hat Kind <strong>*</strong><p>
    </li>
    <li>
      <p><strong>k1->k2</strong> ist der Kind von einstelligen Typ-Konstruktoren, die Typen von Kind <strong>k1</strong> nehmen und Typen von Kind <strong>k2</strong> erzeugen</p>
    </li>
  </ul>
</div>
<div class="slide">
  <h2>Kinds: Beispiele</h2>
  <ul class="incremental">
    <li>
      <pre class="sh_haskell">Int :: *</pre>
      <pre class="sh_haskell">Char :: *</pre>
      <pre class="sh_haskell">Maybe Int :: *</pre>
      <pre class="sh_haskell">Int -> Bool :: *</pre>
    </li>
    <li>
      <pre class="sh_haskell">Maybe :: * -> *</pre>
      <pre class="sh_haskell">(->) :: * -> *</pre>
      <pre class="sh_haskell">(,,) :: * -> * -> *</pre>
    </li>
    <li>
      <pre class="sh_haskell">data Funny f a = Funny a (f a)</pre>
    </li>
    <li>
      <pre class="sh_haskell">Funny :: (* -> *) -> * -> *</pre>
    </li>
  </ul>
</div>
<!--
* Combinatoric Parsing: Attoparsec (astro) (15 min)
* Template Haskell (maloi) (20min)
* Profiling (astro) (15min)
* Parallel Haskell (maloi) (10min)

* Yesod:
 * Conduits (astro) (15 min)
   * 
 * Wai (astro) (10 min)
   * Frontend, middlewares, backend (graphic)
 * Handlers & Hamlet (astro) (25 min)
   * App construction
   * Routing
   * RESTful content
   * Hamlet, Whamlet
   * I18N
 * Persistent (maloi) (10min)
-->

</body>
</html>
